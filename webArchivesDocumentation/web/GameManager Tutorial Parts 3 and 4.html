<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0113)https://web.archive.org/web/20160409060343/http://delta3d.org/article.php?story=20060620134503728&topic=tutorials -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><script src="./GameManager Tutorial Parts 3 and 4_files/cb=gapi.loaded_2" async=""></script><script src="./GameManager Tutorial Parts 3 and 4_files/cb=gapi.loaded_1" async=""></script><script id="twitter-wjs" src="./GameManager Tutorial Parts 3 and 4_files/widgets.js.download"></script><script id="facebook-jssdk" src="./GameManager Tutorial Parts 3 and 4_files/all.js.download"></script><script src="./GameManager Tutorial Parts 3 and 4_files/cb=gapi.loaded_0" async=""></script><script src="./GameManager Tutorial Parts 3 and 4_files/analytics.js.download" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app57.us.archive.org';v.server_ms=659;archive_analytics.send_pageview({});});</script><script type="text/javascript" src="./GameManager Tutorial Parts 3 and 4_files/playback.bundle.js.download" charset="utf-8"></script>
<script type="text/javascript" src="./GameManager Tutorial Parts 3 and 4_files/wombat.js.download" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("http://delta3d.org/article.php?story=20060620134503728&topic=tutorials","20160409060343","https://web.archive.org/","web","/_static/",
	      "1460181823");
</script>
<link rel="stylesheet" type="text/css" href="./GameManager Tutorial Parts 3 and 4_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./GameManager Tutorial Parts 3 and 4_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

    <title>
	    GM Tutorial Parts 3 and 4 - delta3d
    </title>
    
    <meta name="revisit-after" content="2 days">
    <meta name="robots" content="index,follow">
    <meta name="publisher" content="delta3d">
    <meta name="copyright" content="delta3d">
    <meta name="author" content="delta3d">
    <meta name="distribution" content="global">
	<meta http-equiv="Content-Script-Type" content="text/javascript">
	<meta http-equiv="Content-Style-Type" content="text/css">
	<!-- <meta http-equiv="Pragma" content="no-cache"> -->

    <link rel="SHORTCUT ICON" href="https://web.archive.org/web/20160409060343im_/http://delta3d.org/images/favicon.ico">

	

	<link rel="home" href="http://delta3d.org/" title="Home">
<link rel="search" href="https://web.archive.org/web/20160409060343/http://delta3d.org/search.php" title="Advanced Search">
<link rel="contents" href="http://delta3d.org/directory.php" title="Directory">
<link rel="service" type="application/atomsvc+xml" href="http://delta3d.org/webservices/atom/?introspection" title="Webservices">

	<link rel="stylesheet" type="text/css" href="./GameManager Tutorial Parts 3 and 4_files/css.php" media="all">
<link rel="stylesheet" type="text/css" href="./GameManager Tutorial Parts 3 and 4_files/style.css">
<link rel="canonical" href="https://web.archive.org/web/20160409060343/http://delta3d.org/article.php?story=20060620134503728">
<!--
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/"
         xmlns:dc="http://purl.org/dc/elements/1.1/">
<rdf:Description
    rdf:about="http://delta3d.org/article.php?story=20060620134503728"
    trackback:ping="http://delta3d.org/trackback.php?id=20060620134503728"
    dc:title="GM Tutorial Parts 3 and 4"
    dc:identifier="http://delta3d.org/article.php?story=20060620134503728" />
</rdf:RDF>
-->

<!-- Include CSS for Forum -->
<link rel="stylesheet" type="text/css" href="./GameManager Tutorial Parts 3 and 4_files/forum.css">
<link rel="stylesheet" type="text/css" href="./GameManager Tutorial Parts 3 and 4_files/smilies.css.php">
<link rel="stylesheet" type="text/css" href="./GameManager Tutorial Parts 3 and 4_files/style(1).css">
<link rel="stylesheet" type="text/css" href="./GameManager Tutorial Parts 3 and 4_files/QapTcha.jquery.css" media="screen">
	<script type="text/javascript" src="./GameManager Tutorial Parts 3 and 4_files/plusone.js.download" gapi_processed="true"></script>
	
	<link rel="stylesheet" type="text/css" href="./GameManager Tutorial Parts 3 and 4_files/css.php">

    <!--[if lte IE 6]>
        <link rel="stylesheet" type="text/css" href="http://delta3d.org/layout/purepro/css/ie6.css" title="purepro"{xthml}>
    <![endif]-->
    <!--[if IE 7]>
        <link rel="stylesheet" type="text/css" href="http://delta3d.org/layout/purepro/css/ie7.css" title="purepro"{xthml}>
    <![endif]-->

<style type="text/css">.fb_hidden{position:absolute;top:-10000px;z-index:10001}.fb_reposition{overflow:hidden;position:relative}.fb_invisible{display:none}.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:"lucida grande", tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}.fb_reset>div{overflow:hidden}.fb_link img{border:none}@keyframes fb_transform{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}.fb_animate{animation:fb_transform .3s forwards}
.fb_dialog{background:rgba(82, 82, 82, .7);position:absolute;top:-10000px;z-index:10001}.fb_reset .fb_dialog_legacy{overflow:visible}.fb_dialog_advanced{padding:10px;-moz-border-radius:8px;-webkit-border-radius:8px;border-radius:8px}.fb_dialog_content{background:#fff;color:#333}.fb_dialog_close_icon{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 0 transparent;_background-image:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif);cursor:pointer;display:block;height:15px;position:absolute;right:18px;top:17px;width:15px}.fb_dialog_mobile .fb_dialog_close_icon{top:5px;left:5px;right:auto}.fb_dialog_padding{background-color:transparent;position:absolute;width:1px;z-index:-1}.fb_dialog_close_icon:hover{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -15px transparent;_background-image:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif)}.fb_dialog_close_icon:active{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -30px transparent;_background-image:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif)}.fb_dialog_loader{background-color:#f6f7f8;border:1px solid #606060;font-size:24px;padding:20px}.fb_dialog_top_left,.fb_dialog_top_right,.fb_dialog_bottom_left,.fb_dialog_bottom_right{height:10px;width:10px;overflow:hidden;position:absolute}.fb_dialog_top_left{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 0;left:-10px;top:-10px}.fb_dialog_top_right{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -10px;right:-10px;top:-10px}.fb_dialog_bottom_left{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -20px;bottom:-10px;left:-10px}.fb_dialog_bottom_right{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -30px;right:-10px;bottom:-10px}.fb_dialog_vert_left,.fb_dialog_vert_right,.fb_dialog_horiz_top,.fb_dialog_horiz_bottom{position:absolute;background:#525252;filter:alpha(opacity=70);opacity:.7}.fb_dialog_vert_left,.fb_dialog_vert_right{width:10px;height:100%}.fb_dialog_vert_left{margin-left:-10px}.fb_dialog_vert_right{right:0;margin-right:-10px}.fb_dialog_horiz_top,.fb_dialog_horiz_bottom{width:100%;height:10px}.fb_dialog_horiz_top{margin-top:-10px}.fb_dialog_horiz_bottom{bottom:0;margin-bottom:-10px}.fb_dialog_iframe{line-height:0}.fb_dialog_content .dialog_title{background:#6d84b4;border:1px solid #3a5795;color:#fff;font-size:14px;font-weight:bold;margin:0}.fb_dialog_content .dialog_title>span{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/yd/r/Cou7n-nqK52.gif) no-repeat 5px 50%;float:left;padding:5px 0 7px 26px}body.fb_hidden{-webkit-transform:none;height:100%;margin:0;overflow:visible;position:absolute;top:-10000px;left:0;width:100%}.fb_dialog.fb_dialog_mobile.loading{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/ya/r/3rhSv5V8j3o.gif) white no-repeat 50% 50%;min-height:100%;min-width:100%;overflow:hidden;position:absolute;top:0;z-index:10001}.fb_dialog.fb_dialog_mobile.loading.centered{width:auto;height:auto;min-height:initial;min-width:initial;background:none}.fb_dialog.fb_dialog_mobile.loading.centered #fb_dialog_loader_spinner{width:100%}.fb_dialog.fb_dialog_mobile.loading.centered .fb_dialog_content{background:none}.loading.centered #fb_dialog_loader_close{color:#fff;display:block;padding-top:20px;clear:both;font-size:18px}#fb-root #fb_dialog_ipad_overlay{background:rgba(0, 0, 0, .45);position:absolute;bottom:0;left:0;right:0;top:0;width:100%;min-height:100%;z-index:10000}#fb-root #fb_dialog_ipad_overlay.hidden{display:none}.fb_dialog.fb_dialog_mobile.loading iframe{visibility:hidden}.fb_dialog_content .dialog_header{-webkit-box-shadow:white 0 1px 1px -1px inset;background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#738ABA), to(#2C4987));border-bottom:1px solid;border-color:#1d4088;color:#fff;font:14px Helvetica, sans-serif;font-weight:bold;text-overflow:ellipsis;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0;vertical-align:middle;white-space:nowrap}.fb_dialog_content .dialog_header table{-webkit-font-smoothing:subpixel-antialiased;height:43px;width:100%}.fb_dialog_content .dialog_header td.header_left{font-size:12px;padding-left:5px;vertical-align:middle;width:60px}.fb_dialog_content .dialog_header td.header_right{font-size:12px;padding-right:5px;vertical-align:middle;width:60px}.fb_dialog_content .touchable_button{background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#4966A6), color-stop(.5, #355492), to(#2A4887));border:1px solid #2f477a;-webkit-background-clip:padding-box;-webkit-border-radius:3px;-webkit-box-shadow:rgba(0, 0, 0, .117188) 0 1px 1px inset, rgba(255, 255, 255, .167969) 0 1px 0;display:inline-block;margin-top:3px;max-width:85px;line-height:18px;padding:4px 12px;position:relative}.fb_dialog_content .dialog_header .touchable_button input{border:none;background:none;color:#fff;font:12px Helvetica, sans-serif;font-weight:bold;margin:2px -12px;padding:2px 6px 3px 6px;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog_content .dialog_header .header_center{color:#fff;font-size:16px;font-weight:bold;line-height:18px;text-align:center;vertical-align:middle}.fb_dialog_content .dialog_content{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/y9/r/jKEcVPZFk-2.gif) no-repeat 50% 50%;border:1px solid #555;border-bottom:0;border-top:0;height:150px}.fb_dialog_content .dialog_footer{background:#f6f7f8;border:1px solid #555;border-top-color:#ccc;height:40px}#fb_dialog_loader_close{float:left}.fb_dialog.fb_dialog_mobile .fb_dialog_close_button{text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog.fb_dialog_mobile .fb_dialog_close_icon{visibility:hidden}#fb_dialog_loader_spinner{animation:rotateSpinner 1.2s linear infinite;background-color:transparent;background-image:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/yD/r/t-wz8gw1xG1.png);background-repeat:no-repeat;background-position:50% 50%;height:24px;width:24px}@keyframes rotateSpinner{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.fb_iframe_widget{display:inline-block;position:relative}.fb_iframe_widget span{display:inline-block;position:relative;text-align:justify}.fb_iframe_widget iframe{position:absolute}.fb_iframe_widget_fluid_desktop,.fb_iframe_widget_fluid_desktop span,.fb_iframe_widget_fluid_desktop iframe{max-width:100%}.fb_iframe_widget_fluid_desktop iframe{min-width:220px;position:relative}.fb_iframe_widget_lift{z-index:1}.fb_hide_iframes iframe{position:relative;left:-10000px}.fb_iframe_widget_loader{position:relative;display:inline-block}.fb_iframe_widget_fluid{display:inline}.fb_iframe_widget_fluid span{width:100%}.fb_iframe_widget_loader iframe{min-height:32px;z-index:2;zoom:1}.fb_iframe_widget_loader .FB_Loader{background:url(https://web.archive.org/web/20160409060343if_/https://fbstatic-a.akamaihd.net/rsrc.php/v2/y9/r/jKEcVPZFk-2.gif) no-repeat;height:32px;width:32px;margin-left:-16px;position:absolute;left:50%;z-index:4}</style><script type="text/javascript" charset="utf-8" async="" src="./GameManager Tutorial Parts 3 and 4_files/timeline.0eae788bc4fdbe9cd3e72dca3bc26358.js.download"></script><script type="text/javascript" charset="utf-8" async="" src="./GameManager Tutorial Parts 3 and 4_files/button.71000885400e222c3c0eec823f8f93f0.js.download"></script></head>
<body dir="ltr" id="purepro"><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
</style>
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;">
</div><div id="donato" style="position:relative;width:100%;">
  <div id="donato-base">
    <iframe id="donato-if" src="./GameManager Tutorial Parts 3 and 4_files/donate.html" scrolling="no" frameborder="0" style="width:100%; height:100%">
    </iframe>
  </div>
</div><script type="text/javascript">
__wm.bt(625,27,25,2,"web","http://delta3d.org/article.php?story=20060620134503728&topic=tutorials","20160409060343",1996,"/_static/",["/_static/css/banner-styles.css?v=bsmaklHF","/_static/css/iconochive.css?v=qtvMKcIJ"]);
  __wm.rw(1);
</script>
<!-- END WAYBACK TOOLBAR INSERT -->
<div id="body_layer1"><div id="body_layer2"><div id="body_layer3">
<div>
    <a name="top"></a>
    <a href="https://web.archive.org/web/20160409060343/http://delta3d.org/article.php?story=20060620134503728&amp;topic=tutorials#content-start"> <!-- for screenreaders -->
        <img class="hidden" src="./GameManager Tutorial Parts 3 and 4_files/speck.gif" alt="{skip_navigation}">
    </a>
</div>
<!-- End of htmlheader.thtml --><!-- Start of header.thtml -->
    <div id="gl_container">

        <div id="gl_header">
		<div id="header-site-logo-graphic">
	
	<a href="https://web.archive.org/web/20160409060343/http://delta3d.org/" title="delta3d"><img src="./GameManager Tutorial Parts 3 and 4_files/images.php" alt="delta3d"></a>
	
</div>
		
        </div> <!-- end of gl_header -->
		
        
		
        <div id="gl_menu" style="display:block">
            <ul>
            <li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/search.php"><span>Advanced Search</span></a></li>
<li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/directory.php?topic=tutorials"><span>Directory</span></a></li>
<li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/api/"><span>API docs</span></a></li>
<li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/article.php?story=20050720155458456&amp;topic=tutorials"><span>Tutorials</span></a></li>
<li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/deltawiki"><span>Wiki</span></a></li>
<li><a href="https://web.archive.org/web/20160409060343/https://sourceforge.net/projects/delta3d/files/"><span>Download</span></a></li>
<li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/forum"><span>Forum</span></a></li>
<li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/usersettings.php"><span>My Account</span></a></li>

            </ul>
        </div>  <!-- end of gl_menu -->

		<div id="glmenu_plugin" style="display:none">
		 
	    </div>
		
		<div id="navman_plugin" style="display:none">
		
		
	    </div>
		
		<div id="gl_content_container">

        <div id="gl_wrapper">
            <div id="gl_content-wide-left">

<!-- START OF CONTENT AREA -->
                <a name="content-start" id="content-start"></a><!--for screenreaders -->
				<!-- Start of Breadcrumbs Navigation -->
<p>
</p><div itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
    <a href="https://web.archive.org/web/20160409060343/http://delta3d.org/index.php" itemprop="url">
    <span itemprop="title">Home</span>
</a> &gt;
<span itemprop="child" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
    <a href="https://web.archive.org/web/20160409060343/http://delta3d.org/index.php?topic=tutorials" itemprop="url">
    <span itemprop="title">Tutorials</span>
</a> 



</span>




</div>
<p></p>
<!-- End of Breadcrumbs Navigation -->

				
<!-- End of header.thtml -->
        <div class="story">
	<span class="story-icons">  
        
        
        
        
    </span>
    <h1>GM Tutorial Parts 3 and 4</h1>
	<div class="story-information">
    	<a class="storybyline" href="https://web.archive.org/web/20160409060343/http://delta3d.org/users.php?mode=profile&amp;uid=13" rel="author">coonan</a> Tuesday, June 20 2006 @ 08:45 PM UTC Views: 18,838  
    </div>
    <div class="story-body">
        We now continue on to the second half of our Game Manager Tutorial. Click <a href="https://web.archive.org/web/20160409060343/http://www.delta3d.org/article.php?story=20060620123144266&amp;topic=tutorials">here</a> to go to the previous part.<br><br><h1>Part Three – Creating a Game with GameStart</h1>
<h2>Game Start and the GameEntryPoint Library</h2>
<p>
We now have an Actor, but how do we go from that to a working game? The Game Manager architecture provides a new entry point for your applications called GameStart.  GameStart is a free standing executable that you can use to start up your applications without having to build your own executable.  GameStart works by looking for a GameEntryPoint class in your library. Once it finds your entry point, it calls 3 methods and then kicks off its own GameApplication and runs the game loop. The GameEntryPoint is to GameStart as the ActorPluginRegistry is to an ActorLibrary.  This is a simple, but required step. GameEntryPoint has the following 3 methods:
</p>
<p>
</p><ol>
<li>Initialize() – Passes in any command line params.  Typically, you just want to grab any params you need.  However, Initialize() is also your opportunity to do any very early configuration work – stuff that needs to be done before anything else. Do not do any GM work in here. Overriding this method is optional.</li>
<li>CreateGameManager() – A short and sweet method where the actual GameManager instance is created. Override this in the unusual case that have a subclass of GameManager. The base implementation creates a dtGame::GameManager for you. </li>
<li>OnStartup() – Where the fun begins! Create all your components, load your map, and do any other work you need to do to startup your game.  This is the last thing that is called before your infinite game loop starts.  This method is required!</li>
</ol>
<p></p>
<p>
So, if you’ve already written a Delta3D app, you’ve almost certainly used dtABC::Application.  So, why in the world should you use a GameEntryPoint over a dtABC::Application? Well, the primary reason is that it makes your system configurable. GameStart mirrors the type of setup that most game engines have. Consider Unreal and other modern engines. They use the same executable to start – an executable that usually comes ready to run, right out of the box. You simply build your custom library or map and tell the executable to go!  
</p>
<p>
This is really the only way you can ever run an app directly from an editor. Yep, you heard that right. Using GameEntryPoint, future versions of STAGE could be able to launch your app right from the editor. Heck, you could even have separate test versions of your GameEntryPoint that test single levels or stub out network behavior!
</p>
<p>
<i>
Helpful Hint – The Initialize() method lets you customize how your game runs by providing a way to get command line parameters. Since Initialize() is the very first thing called, you can use this method to support various test modes or alternate configurations of your application.
</i>
</p>
<p>
</p><h2>Game Start and the GameEntryPoint Library</h2>
<p></p>
<p>
Once you have a GameEntryPoint in your library, then running GameStart would look like this:
</p>
<p>
</p><pre><code>
“GameStart.exe MyCoolLibrary”
</code></pre>
<p></p>
<p>
So the question is: how do you create a GameEntryPoint? Well, if GameStart is looking for a library, then obviously, we’re going to need a library to put it in.  Fortunately we already have one – the HoverTank actor library! We can just put our entry point class there.  All we need to do now is create our GameEntryPoint class and implement our methods.  In our case, we will take the default implementation for Initialize() and CreateGameManager(), so all we need to implement is OnStartup(). Here’s what it looks like.
</p>
<p>
In “TutorialGameEntryPoint.h”:
</p>
<p>
</p><pre><code>
#include "export.h"
#include &lt;dtCore/refptr.h&gt;
#include &lt;dtGame/gameentrypoint.h&gt;

namespace dtGame
{
   class GameApplication;
   class GameManager;
   class GameActorProxy;
}

/**
 * Our entry point into the game.  The GameStart.exe application can load this like this:
 *     "GameStartd.exe TutorialGameActors"
 * We create our Game Manager and components in this class.
 */ 
class TUTORIAL_HOVER_EXPORT TutorialGameEntryPoint: public dtGame::GameEntryPoint
{
   public:
      TutorialGameEntryPoint() { };
      virtual ~TutorialGameEntryPoint() { };

      // Called to do early initializtion.  Grab your command line params here.
      // We just use the base implementation
      //virtual void Initialize(dtGame::GameApplication&amp; app, int argc, char **argv) 
      //   throw (dtUtil::Exception);

      // Create your game manager.
      // We just use the base implementation
      // virtual dtCore::RefPtr&lt;dtGame::GameManager&gt; CreateGameManager(dtCore::Scene&amp; scene);

      // Called just before your application's game loop starts.  This is your main 
      // opportunity to create components, load maps, create unique actors, etc...
      virtual void OnStartup(dtGame::GameManager &amp;gameManager);
};
</code></pre>
<p></p>
<p>
With just one method to implement, this class is about as simple as it gets.
</p>
<p>
In “TutorialGameEntryPoint.cpp”:
</p>
<p>
</p><pre><code>
#include "TutorialGameEntryPoint.h"
#include "TutorialInputComponent.h"

#include &lt;dtGame/gamemanager.h&gt;
#include &lt;dtGame/defaultmessageprocessor.h&gt;
#include &lt;dtGame/gameapplication.h&gt;

#include &lt;dtCore/camera.h&gt;
#include &lt;dtCore/flymotionmodel.h&gt;
#include &lt;dtCore/camera.h&gt;
#include &lt;dtCore/keyboard.h&gt;

#include &lt;dtDAL/project.h&gt;
#include &lt;dtABC/application.h&gt;


//////////////////////////////////////////////////////////////////////////
extern "C" TUTORIAL_HOVER_EXPORT dtGame::GameEntryPoint* CreateGameEntryPoint()
{
   return new TutorialGameEntryPoint;
}

//////////////////////////////////////////////////////////////////////////
extern "C" TUTORIAL_HOVER_EXPORT void DestroyGameEntryPoint(dtGame::GameEntryPoint* entryPoint)
{
   delete entryPoint;
}

//////////////////////////////////////////////////////////////////////////
void TutorialGameEntryPoint::OnStartup(dtGame::GameManager &amp;gameManager)
{
   // Add Component - DefaultMessageProcessor 
   dtGame::DefaultMessageProcessor *dmp = new dtGame::DefaultMessageProcessor("DefaultMessageProcessor");
   gameManager.AddComponent(*dmp,dtGame::GameManager::ComponentPriority::HIGHEST);

   // Add Component - Input Component
   dtCore::RefPtr&lt;TutorialInputComponent&gt; inputComp = new TutorialInputComponent("TutorialInputComponent");
   gameManager.AddComponent(*inputComp, dtGame::GameManager::ComponentPriority::NORMAL);

   // Load the map we created in STAGE.
   dtDAL::Project::GetInstance().SetContext("StageProject");
   gameManager.ChangeMap("HoverMap");
   gameManager.GetScene().UseSceneLight(true);

   // Attach our camera to the fly motion model..
   dtABC::Application&amp; app = gameManager.GetApplication();
   dtCore::FlyMotionModel *fmm = new dtCore::FlyMotionModel
         (app.GetKeyboard(), app.GetMouse(), false);
   fmm-&gt;SetTarget(app.GetCamera());
   
   // Set initial camera position so we can see our tank
   dtCore::Transform tx(0.0f,-40.0f,15.0f,-50.0f,-15.0f,0.0f);
   app.GetCamera()-&gt;SetTransform(&amp;tx); 
}
</code></pre>
<p></p>
<p>
That’s it! We have the boiler plate entry point code: CreateGameEntryPoint() and DestroyGameEntryPoint(). Those create and destroy your instance of the TutorialGameEntryPoint class. Then, we implement the one simple method: OnStartup(). There, we created a couple components for default message processing and keyboard input, load our map, attach a motion model, and position our camera.  That’s less than 15 lines of code total.
</p>
<h2>DefaultMessageProcessor and Component Priority</h2>
<p>
Create our DefaultMessageProcessor: 
</p>
<p>
</p><pre><code>
   dtGame::DefaultMessageProcessor *dmp = new dtGame::DefaultMessageProcessor("DefaultMessageProcessor");
   gameManager.AddComponent(*dmp,dtGame::GameManager::ComponentPriority::HIGHEST);
</code></pre>
<p>
You must ALWAYS do this when you create the Game Manager or else your actors will not get spawned properly, and basically none of the “default” message handling will occur.  You may be asking yourself, “Well why doesn’t the Game Manager do this for you?”  The answer is simple, the DefaultMessageProcessor is meant to be extended to suit the needs of your game or simulation.  If your application needs to intercept actor create messages, update messages, or actor destroy messages, then you can create your own DefaultMessageProcessor. You might want to have one default processor on a client and a different one on the server.  Or you might have different processors for a variety of apps using the same base code.  
</p>
<p>
Overriding the DefaultMessageProcessor actually gives you the ability to CHANGE the way actors are created, destroyed, and updated. Before we wrap up the default message processor discussion, please note one other VERY IMPORTANT thing about the code.  When you add an instance of the DefaultMessageProcessor be sure to add it with the HIGHEST priority level.  All components have an associated priority level:  HIGHEST, HIGHER, NORMAL, LOWER, LOWEST.  These priorities determine the order in which components process messages going through the Game Manager.  Since we almost always want the DefaultMessageProcessor to get messages before other components we add it in the HIGHEST priority queue. Think about it, the DefaultMessageProcessor creates actor instances, destroys them, and updates their properties. We better do that stuff first, so that other components that may be listening for actor messages can be confident that the actor has already been created, destroyed, or updated!  It would stink to get an ActorUpdate message only to find that the properties haven’t changed yet!
</p>
<h2>Finishing our GameEntryPoint</h2>
<p>
The next thing we do is add our input component. This is a new class that we haven’t talked about yet.  We’ll get to that later. Here’s the code:
</p>
<p>
</p><pre><code>
   dtCore::RefPtr&lt;TutorialInputComponent&gt; inputComp = new TutorialInputComponent("TutorialInputComponent");
   gameManager.AddComponent(*inputComp, dtGame::GameManager::ComponentPriority::NORMAL);
</code></pre>
<p></p>
<p>
The next portion of code in the above snippet sets our project context and loads a map.  The Game Manager makes loading maps even easier than you see in the Actor tutorial (LINK). 
</p>
<p>
</p><pre><code>
   dtDAL::Project::GetInstance().SetContext("StageProject");
   gameManager.ChangeMap("HoverMap");
   gameManager.GetScene().UseSceneLight(true);
</code></pre>
<p></p>
<p>
Pretty simple isn’t it?  Set out project context and tell the Game Manager to load our map.  That’s it!  Just in case you’re wondering about the last line of code.  We tell the scene to use the default skylight after the map is loaded since loading a map effectively clears all drawables from the scene including the default sky light that may have been present.  So we have to tell the scene to use the default light AFTER loading the map. If your map uses actors for lights and they are in your map, then you can skip this line. When ChangeMap() is finished, it will send a MAP_CHANGE message. Technically the GM hasn’t really started processing messages yet, so it just puts it in the queue for the next tick.  We’ll talk more about that later. 
</p>
<p>
The last thing we do is setup a motion model and position our camera. Very typical Delta3D code for this: 
</p>
<p>
</p><pre><code>
   // Attach our camera to the fly motion model..
   dtABC::Application&amp; app = gameManager.GetApplication();
   dtCore::FlyMotionModel *fmm = new dtCore::FlyMotionModel(app.GetKeyboard(), app.GetMouse(), false);
   fmm-&gt;SetTarget(app.GetCamera());
   
   // Set initial camera position so we can see our tank
   dtCore::Transform tx(0.0f,-40.0f,15.0f,-50.0f,-15.0f,0.0f);
   app.GetCamera()-&gt;SetTransform(&amp;tx); 
</code></pre>
<p></p>
<p>
If you are running in Linux, you should be able to go to the directory where you built your library, and type, “GameStart.exe TutorialGameActors”.  If you are running Visual Studio, you need to setup your project to look something like this:
</p>
<p>
</p><center>
<img width="528" height="361" src="./GameManager Tutorial Parts 3 and 4_files/20060620134503728_2.jpg" alt="">
<br>
<b>Figure 7. GameStart Project Settings in Visual Studio</b>
</center>
<p></p>
<p>
That’s it for this section. Except for the TutorialInputComponent, which we haven’t created yet, you should have enough code here to compile and run. Already, you have created a GM, handled basic actor messages, loaded a map, and setup a camera.  If you run it, you should be able to see your tank, see the terrain, and fly the camera around the world! Now it’s time to do some fun stuff with our tank!
</p>
<p>
<i>
Helpful Hint – Although GameStart and the GameEntryPoint make it a lot easier to create a GameManager based application, they are not required.  You can still choose to build an Application to run your game loop.  In fact, GameStart uses its own Application class called GameApplication. The note here is that if you do use GameStart, you will not be able to use your own Application. So, if you already have an Application class for your project, pull the code from your Application subclass and put it in a component, actor, or the GameEntryPoint.
</i>
</p>
<h1>Part Four – Messages and Invokables</h1>
<p>
In this section we are going to talk about game events, invokables, and ticks.  Say, what?  Don’t worry, we’ll explain everything you need to know. Basically we are going to build some code to send messages when the user presses certain keys.  Then, we’re going to add code to our hover tank to receive those messages and turn its engines on and off.  Finally, we’re going to show how we can move our tank around and ground clamp it by listening for ticks.
</p>
<p>
</p><h2>Game Events</h2>
<p>
To get us started sending and receiving messages, let’s talk a little bit about GameEvents. GameEvents are simple string identifiers that are sent out in a special GameEventMessage when some significant event occurs. Game Events represent a single action such as ‘Apple Found’, or ‘Hostage Rescued’.  Since sometimes, people are confused about the difference, let’s be really clear: a GameEvent is a simple data class and a GameEventMessage is an message that sends a GameEvent. 
</p>
<p>
In order to keep track of all the GameEvents in the system, we created dtDAL::EventManager.  The EventManager is a singleton class that provides a simple management layer to allow you to look up game events from anywhere. To use a GameEvent, you create it and then register it with the EventManager (in dtDAL). Future versions of STAGE will let you define your GameEvents directly in your map. The code looks like this:
</p>
<p>
</p><pre><code>
   mToggleEngineEvent = new dtDAL::GameEvent("ToggleEngine");
   dtDAL::GameEventManager::GetInstance().AddEvent(*mToggleEngineEvent);
</code></pre>
<p></p>
<p>
We’re going to see it in use below.  At this point, we are able to create a game event, but how do we send them through the Game Manager to other actors and components? We use a GameEventMessage of course.  A GameEventMessage is a very simple message with a single parameter for the GameEvent. Telling the Game Manager to send a game event message is analogous to “firing” the event.  We’ll see it all in action when we create our TutorialInputComponent at the bottom of this section, but here’s the snippet to fire a game event message.
</p>
<p>
</p><pre><code>
   dtCore::RefPtr&lt;dtGame::GameEventMessage&gt; eventMsg;
   GetGameManager()-&gt;GetMessageFactory().CreateMessage(dtGame::MessageType::INFO_GAME_EVENT, eventMsg);

   eventMsg-&gt;SetGameEvent(event);
   GetGameManager()-&gt;SendMessage(*eventMsg);   
</code></pre>
<p></p>
<p>
We first create an event message using the GM’s message factory. Once we have our message created, we bind a game event to it and tell the Game Manager to process the message.  
</p>
<p>
Note that GameEvents take a string identifier in their constructor.  They can optionally take a description as well.  In order to access GameEvents from the GameEventManager, you need to ask for them by those string identifiers.  So in a real world application, you’ll probably want to put these in some sort of resources file, or some other common place.  Future versions of STAGE, the Delta3D level editor, will have UI’s for editing these events in which case they will be loaded with your map automatically.  
</p>
<h2>Invokables</h2>
<p>
We can now create and send GameEvents, but how do we receive them?  To answer that, we need to talk a bit about invokables.  Think about invokables as event callbacks, except that they are handled and managed much like properties.  To quote the <a href="https://web.archive.org/web/20160409060343/http://www.delta3d.org/article.php?story=20051207101455773&amp;topic=docs" target="_blank">Game Manager Design Document</a>, “Invokables are to method calls what properties are to data members.  Just like a property, invokables are created when the proxy is created, have names, and can be requested by name.  Like a method, they can be called, or invoked.”  In this section, we’ll look at how to use invokables to respond to our new game events. 
</p>
<p>
If an invokable is basically just a method, then the first thing we need to do is create an invokable method. Here’s what one looks like: 
</p>
<p>
In “HoverTankActor.cpp”:
</p>
<p>
</p><pre><code>
///////////////////////////////////////////////////////////////////////////////
void HoverTankActor::ProcessMessage(const dtGame::Message &amp;message)
{
   if (message.GetMessageType() == dtGame::MessageType::INFO_GAME_EVENT)
   {
      const dtGame::GameEventMessage &amp;eventMsg = static_cast&lt;const 
            dtGame::GameEventMessage&amp;&gt;(message);

      // Note, we are using strings which aren't constants.  In a real application, these 
      // event names should be stored in some sort of shared place and should be constants...
      if (eventMsg.GetGameEvent() != NULL)
      {
         // Handle "ToggleEngine" Game Event
         if (eventMsg.GetGameEvent()-&gt;GetName() == "ToggleEngine")
         {
            mIsEngineRunning = !mIsEngineRunning;
	    mDust-&gt;SetEnabled(mIsEngineRunning);
         } 
         // Handle "SpeedBoost" Game Event
         else if (eventMsg.GetGameEvent()-&gt;GetName() == "SpeedBoost")
         {
            SetVelocity(mVelocity + -5.0f);
         }
      }
   }
}
</code></pre>
<p></p>
<p>
Hey, wait!  There’s nothing special in that code!  It’s just a simple method that takes a message! Well, you’re right of course because that’s basically the whole reason we have Invokables! It’s just a method on your class that takes a message as a parameter. We just check to see what type of message we received, and react appropriately.
</p>
<p>
In this case, we are using the default Invokable called ProcessMessage(). GameActorProxy provides two other default Invokables as well: TickLocal() and TickRemote(). However, there are times when you want to create your own Invokable. To do that, you need to create your handler method and then wrap it in an Invokable. You do this in the BuildInvokables() method located in your GameActorProxy.  BuildInvokables is called when the game actor is created. 
</p>
<p>
</p><pre><code>
// Not part of the tutorial – provided as an example of creating an Invokable
///////////////////////////////////////////////////////////////////////////////
void XYZProxy::BuildInvokables()
{
   XYZActor &amp;actor = static_cast&lt;XYZActor&amp;&gt;(GetGameActor());
   dtActors::GameMeshActorProxy::BuildInvokables();

   // create our invokable for events
   AddInvokable(*new dtGame::Invokable(“My Call Back”, dtDAL::MakeFunctor(actor,&amp;XYZ::MyMethod)));
}
</code></pre>
<p></p>
<p>
Next, we need to register our invokable with the Game Manager. We’ll do this in the method OnEnteredWorld(). That’s called when the game actor is added to the Game Manager. Make sure to use the same string name for your invokable when you create it and when register it. Here is what it looks like. 
</p>
<p>
In “HoverTankActor.cpp”:
</p>
<p>
</p><pre><code>
///////////////////////////////////////////////////////////////////////////////
void HoverTankActorProxy::OnEnteredWorld()
{
   //Register an invokable for Game Events...
   RegisterForMessages(dtGame::MessageType::INFO_GAME_EVENT);

   // Register an invokable for tick messages. Local or Remote only, not both!
   if (IsRemote())
      RegisterForMessages(dtGame::MessageType::TICK_REMOTE, dtGame::GameActorProxy::TICK_REMOTE_INVOKABLE);
   else
      RegisterForMessages(dtGame::MessageType::TICK_LOCAL, dtGame::GameActorProxy::TICK_LOCAL_INVOKABLE);

   dtActors::GameMeshActorProxy::OnEnteredWorld();
}
</code></pre>
<p></p>
<p>
It’s just one line of code to register for a message type.  Then, we take a little side trip to register handlers for TICK_REMOTE and TICK_LOCAL. We haven’t really talked about ticks yet, but just know that Ticks are messages too! So naturally, if our Actor has to register to receive message like GameEventMessage, then we have to register for ticks too. In this code, we register for either the local or remote ticks and use the default Invokables, TickLocal() and TickRemote(). We’ll learn more about this in just a moment. To recap, we wrote a method called ProcessMessage() and registered to receive tick and game event messages from the Game Manager.
</p>
<p>
Now, let’s go add some fun code to our tank to add a particle system! For this, we’re going to override the OnEnteredWorld() method on our actor. Didn’t we just do that?  No, we overrode the method on our PROXY. Our Actor has one too, and we can override it.  Although the proxy’s OnEnteredWorld is called first, both are called when the game actor is added to the GM.  Here’s what it looks like:
</p>
<p>
In “HoverTankActor.cpp”:
</p>
<p>
</p><pre><code>
///////////////////////////////////////////////////////////////////////////////
void HoverTankActor::OnEnteredWorld()
{
   // add our dust particle
   mDust = new dtCore::ParticleSystem();
   mDust-&gt;LoadFile("Particles/dust.osg",true);
   mDust-&gt;SetEnabled(false);
   AddChild(mDust.get());

   dtActors::GameMeshActor::OnEnteredWorld();
}
</code></pre>
<p></p>
<p>
Well, that’s pretty simple.  Just create a particle system, load our particle, make sure it’s off when we start, and attach it to our actor.  
</p>
<p><i>
Helpful Hint – There are two other ways to Register for messages: RegisterForMessagesAboutOtherActor() and RegisterForMessagesAboutSelf(). Unlike this simple tutorial, your actors will typically only be interested in messages about itself. For instance, in a more robust game, our HoverTank would only want it’s own “ToggleEngine” messages. After all, when other players turn off their engines, we don’t want ours to shut down too! For that, we would have used, RegisterForMessagesAboutSelf(dtGame::MessageType::INFO_GAME_EVENT) in the OnEnteredWorld() method. Then, we would revisit TutorialInputComponent::FireGameEvent() and set the about actor id like this: eventMsg-&gt;SetAboutActorId(…).</i> 
</p>
<p>
</p><h2>An Input Component</h2>
<p></p>
<p>
Now we have some nifty behavior to handle game event messages, but if we compile right now, it won’t do anything. Why? Because no one is sending those events! Let’s spice up our app by trapping keyboard events and sending messages! In other tutorials, you learned how to trap HandleKeyPressed() in your Application class.  However, we just learned that we can’t put our code in Application anymore. So, where should it go?  Well, obviously the GM must have some sort of way for handling key events. But, the GM works with Actors and Components.  …  What to do?
</p>
<p>
Well, hopefully, you already guessed that we’re going to need a component. After all, the GM works primarily with (1) Messages, (2) Actors, and (3) Components. Since our goal is to cause a (1) Message to go to an (2) Actor, that really only leaves a (3) Component. Components, have a very long life span, so they can work at a very high level. In fact, GMComponents were specifically intended to support high level behavior – such as keyboard input. 
</p>
<p>
What we want to use is dtGame::BaseInputComponent.  This class already knows how to trap keyboard and mouse events.  All we need to do is override whichever mouse/keyboard behavior we want to support.  For this tutorial, we’re looking for Keyboard Pressed behavior.  First, we need to define our class: 
</p>
<p>
In “TutorialInputComponent.h”:
</p>
<p>
</p><pre><code>
#include "export.h"
#include &lt;dtCore/refptr.h&gt;
#include &lt;dtGame/baseinputcomponent.h&gt;
#include &lt;dtDAL/gameevent.h&gt;
#include &lt;dtDAL/gameeventmanager.h&gt;

/**
 * This is an example use of the base input component for our tutorial. We will put 
 * all of our keyboard and mouse event handling in here. As a GM component, it will
 * also receive all game messages in ProcessMessage() and DispatchNetworkMessage().
 */
class TUTORIAL_HOVER_EXPORT TutorialInputComponent : public dtGame::BaseInputComponent
{
   public:
      // Constructor
      TutorialInputComponent(const std::string &amp;name);

      // We're going to handle key presses!
      bool HandleKeyPressed(const dtCore::Keyboard* keyboard,
         Producer::KeyboardKey key,Producer::KeyCharacter character);

      // Handle messages from the GM – none for now, so we ignore
      //void ProcessMessage(const dtGame::Message &amp;message);

   protected:
      /// Destructor
      virtual ~TutorialInputComponent() { }

   private:
      // Simple helper method to fire a GameEventMessage.  This method creates the game 
      void FireGameEvent(dtDAL::GameEvent &amp;event);

      // Our GameEvents that we want to fire when the user presses keys
      dtCore::RefPtr&lt;dtDAL::GameEvent&gt; mToggleEngineEvent;
      dtCore::RefPtr&lt;dtDAL::GameEvent&gt; mSpeedBoost;
   };
</code></pre>
<p></p>
<p>
Note that our component doesn’t even override ProcessMessage().  Although that seems strange, it’s a great illustration that GMComponents can do all sorts of high level behavior. Most of your components will override ProcessMessage(), but it is not required. Now for the implementation!
</p>
<p>
First, let’s construct our class.  In “TutorialInputComponent.cpp”:
</p>
<p>
</p><pre><code>
////////////////////////////////////////////////////////////////////
TutorialInputComponent::TutorialInputComponent(const std::string &amp;name) :
   dtGame::BaseInputComponent(name)
{
   // Create a few game events and register them with the event manager.
   mToggleEngineEvent = new dtDAL::GameEvent("ToggleEngine");
   dtDAL::GameEventManager::GetInstance().AddEvent(*mToggleEngineEvent);

   mSpeedBoost = new dtDAL::GameEvent("SpeedBoost");
   dtDAL::GameEventManager::GetInstance().AddEvent(*mSpeedBoost);
}
</code></pre>
<p>
The only thing we’re doing here is constructing our GameEvents (“ToggleEngine” and “SpeedBoost”) and registering them for later use. Note that we pass a name for our component to the BaseInputComponent. All components are required to have a unique name.  This let’s you get access to your components anywhere, anytime, by calling GetComponentByName(“MyName”) on the GM. 
</p>
<p>
Now, let’s handle keyboard events.  In “TutorialInputComponent.cpp”:
</p>
<p>
</p><pre><code>
////////////////////////////////////////////////////////////////////
bool TutorialInputComponent::HandleKeyPressed(const dtCore::Keyboard* keyboard,
   Producer::KeyboardKey key, Producer::KeyCharacter character)
{
   bool handled = true;
   switch(key)
   {
      // 'Space' - Toggle engines on and off
      case Producer::Key_space:
         FireGameEvent(*mToggleEngineEvent);
         break;

      // 'Return' - Give the tank a speed boost
      case Producer::Key_Return:
         FireGameEvent(*mSpeedBoost);
         break;

      // '+' - Speed up simulation time factor, just for fun
      case Producer::Key_equal:
         GetGameManager()-&gt;ChangeTimeSettings(GetGameManager()-&gt;GetSimulationTime(),
            GetGameManager()-&gt;GetTimeScale() * 1.1, GetGameManager()-&gt;GetSimulationClockTime());
         break;

      // '-' - Slow down the simulation time factor
      case Producer::Key_minus:
         GetGameManager()-&gt;ChangeTimeSettings(GetGameManager()-&gt;GetSimulationTime(),
            GetGameManager()-&gt;GetTimeScale() * 0.9, GetGameManager()-&gt;GetSimulationClockTime());
         break;

      default:
         handled = false;
         break;
   }

   // the default case handles the escape key to quit.
   if (!handled)
      return BaseInputComponent::HandleKeyPressed(keyboard, key, character);

   return handled;
}
</code></pre>
<p></p>
<p>
That’s pretty simple.  For ‘space’, we fire our “ToggleEngine” event.  For ‘Return’, we fire our “SpeedBoost” event.  Then, just for fun, we trap the ‘+’ and ‘-‘ keys.  When pressed, we speed up or slow down the simulation time factor by 10%. Although the code is trivial, it’s the first time we’ve really talked about time.  
</p>
<p>
As you’ll see later when we handle the TickLocal() behavior, you should always plan to deal with Simulation Time, as opposed to Real Time.  Real Time is the actual clock change, where 1 real second from the CPU = 1 second.  You might use Real Time for dealing with frame rate issues (such as slow downs or processing bottle necks).  However, for anything else, you should use Simulation (Sim) Time.  Sim time is the virtual time that the simulation thinks it has been running. As we see above, you can slow down and speed up sim time.  If you are using the delta (i.e. change) in simulation time, your application should NEVER know the difference.  Using this, you could implement rudimentary ‘bullet time’ with one line of code!
</p>
<p>
Ok, here’s our last bit of code.  In “TutorialInputComponent.cpp”:
</p>
<p>
</p><pre><code>
//////////////////////////////////////////////////////////////////////////
void TutorialInputComponent::FireGameEvent(dtDAL::GameEvent &amp;event)
{
   dtCore::RefPtr&lt;dtGame::GameEventMessage&gt; eventMsg;
   GetGameManager()-&gt;GetMessageFactory().CreateMessage(dtGame::MessageType::INFO_GAME_EVENT, eventMsg);

   eventMsg-&gt;SetGameEvent(event);
   GetGameManager()-&gt;SendMessage(*eventMsg);   
}
</code></pre>
<p></p>
<p>
A simple utility method.  It gets the GameManager’s MessageFactory and asks it to create a GameEventMessage.  Then, it sets the event parameter of the message and tells the GM to SendMessage().  This is exactly the process you will use to send messages anywhere in the game.  
</p>
<p>
<i>
Helpful Hint – Calling ChangeTimeSettings() on the GM will cause a message to be sent out.  It sends a INFO_TIME_CHANGED message of class dtGame::TimeChangeMessage. You can catch this if need be in ProcessMessage().
</i>
</p>
<h2>Tick, Tock:  Ticking our Tank</h2>
<p>
Well by now you should have a “cool” hover tank actor that we have added to a STAGE map.  We have learned how to create our GameEntryPoint, create a GameManager, create a new component, load our map, and add everything to our GM.  We have created some game events and instructed the Game Manger to send GameEventMessages when the user presses a key on the keyboard.  Lastly, we have added code to our hover tank actor to respond to those messages and turn its engines on and off.  Not too bad, but we still have a little bit more work to do.  
</p>
<p>
If you’ve been writing this code as you go, you’ve already noticed that our poor hover tank can’t move.  What we want to do is allow the user to move our tank smoothly around the world.  Plus, it would be cool if our hover tank actually ‘hovered’ over the ground, so we’ll need to do some ground clamping as its moves about.
</p>
<p>
So how are we going to do that? More importantly, where are we going to do that? Well, to make our movement smooth, we need to process the tank every single time we draw a frame.  So, if our system can draw at 20 Frames per second (FPS), we want to reposition our tank 20 times a second. If it can draw at 300 FPS, then we’ll move it 300 times! That’s where the game loop comes in.
</p>
<p>
So what’s a game loop?  In its simplest form, a game loop is an infinite loop that tells all the parts of the game to do work.  Every time the game loop ‘loops’, it tells all parts of the system to do a little bit of work.  Well, one ‘loop’ is called a ‘tick’.  Although not technically the same, a ‘tick’ is often used interchangeably with ‘frame’. If you don’t take into consideration advanced tick optimization or multi-threaded game loops, then basically the game-loop is just a way of ‘ticking’ everything once per frame. 
</p>
<p>
Ok, so we have an idea of what a game loop is and that ticking is related to updating your game simulation, so how does that translate into actor ticks? Well, pretty simple actually. As long as your game is running, the GameManager will send TICK_LOCAL and TICK_REMOTE messages.  In fact, all ticking is done with messages. Why? Well, that’s a very good question. We could have just called the TickLocal() and TickRemote() methods on your GameActors every tick.  But, wait a minute.  What about actors that don’t need to be ticked?  What about static meshes like trees and terrain and projective textures? What about actors that are simply waiting for specific game events? We don’t want them to be ticked do we? Since game worlds can have thousands of actors, we don’t really want to make 2000-3000 needless calls every tick, do we?  No, we certainly don’t. So, Actors have to register for ticks if they want to receive them.  
</p>
<p>
If you remember, we did that up above.  Here’s what it looked like:
</p>
<p>
</p><pre><code>
void HoverTankActorProxy::OnEnteredWorld()
{
   // …
   // Register an invokable for tick messages. Local or Remote only, not both!
   if (IsRemote())
      RegisterForMessages(dtGame::MessageType::TICK_REMOTE, dtGame::GameActorProxy::TICK_REMOTE_INVOKABLE);
   else
      RegisterForMessages(dtGame::MessageType::TICK_LOCAL, dtGame::GameActorProxy::TICK_LOCAL_INVOKABLE);
   // …
}
</code></pre>
<p></p>
<p>
By default, GameActors already have Invokables for this called TickLocal() and TickRemote(). So, all we have to do is override them.  We did that up above, but now we’re ready to implement the code.
</p>
<p>
In “HoverTankActor.cpp”:
</p>
<p>
</p><pre><code>
///////////////////////////////////////////////////////////////////////////////
void HoverTankActor::TickLocal(const dtGame::Message &amp;tickMessage)
{
   const dtGame::TickMessage &amp;tick = static_cast&lt;const dtGame::TickMessage&amp;&gt;(tickMessage);
   float deltaSimTime = tick.GetDeltaSimTime();

   ComputeVelocityAndTurn(deltaSimTime);

   MoveTheTank(deltaSimTime);
}
</code></pre>
<p></p>
<p>
Ok, that’s pretty simple.  When we get a tick local message we compute our new velocity, turn our vehicle, and then move the tank.  Please note again the use of the simulation time.  Tick.GetDeltaSimTime() will return the change in simulation time since our last tick.  So, if we were getting 10 frames a second and the speed factor was 1, deltaSimTime would be very close to 0.1.  If we were getting 300 frames a second and the speed factor was 1.5x, deltaSimTime would be very close to 0.00499.  Even though the delta’s are wildly different, our game shouldn’t care.  As long as we calculate based on the deltaSimTime, we don’t need to know the difference in frame rate or in speed factor.
</p>
<p>
So, we just implemented our ‘local’ behavior.  But what is this concept of ‘remote’?  Well, if you’ve never written a game or simulation before, it will seem odd.  Local behavior is what we do when we ‘own’ the object. In a single player game, you typically own all the objects on your machine, so everything is ‘local’.  However, in a networked game, you only own your objects (like Player).  You don’t own the other players.  Since you don’t own them, you shouldn’t be simulating them, should you? No. So, the bottom line is that you need perform different behavior when the actor is owned by you (‘local’) than you would if the actor is not-owned by you (‘remote’). Let’s consider our tank. When we ‘own’ the tank, we’re going to recompute the velocity and rotation. After all, our users will be able to steer the tank.  But, we don’t want other clients changing the direction and velocity, we just want them to move the tank!  Let’s see the difference:
</p>
<p>
In “HoverTankActor.cpp”:
</p>
<p>
</p><pre><code>
///////////////////////////////////////////////////////////////////////////////
void HoverTankActor::TickRemote(const dtGame::Message &amp;tickMessage)
{
   const dtGame::TickMessage &amp;tick = static_cast&lt;const dtGame::TickMessage&amp;&gt;(tickMessage);
   float deltaSimTime = tick.GetDeltaSimTime();

   // do NOT recompute velocity and turn rate since we don't own this tank!

   MoveTheTank(deltaSimTime);
}
</code></pre>
<p></p>
<p>
Note that we don’t call ComputeVelocityAndTurn() this time.  Cool! Now, let’s actually move our tank.  This next bit of code is fairly complex and we’re not going to cover it in detail.  Just know that it works. 
</p>
<p>
In “HoverTankActor.cpp”:
</p>
<p>
</p><pre><code>
///////////////////////////////////////////////////////////////////////////////
void HoverTankActor::MoveTheTank(float deltaSimTime)
{
   dtCore::Transform tx;
   osg::Matrix mat;
   osg::Quat q;
   osg::Vec3 viewDir;

   GetTransform(&amp;tx);
   tx.GetRotation(mat);
   mat.get(q);
   viewDir = q * osg::Vec3(0,-1,0);

   // translate the player along its current view direction based on current velocity
   osg::Vec3 pos;
   tx.GetTranslation(pos);
   pos = pos + (viewDir*(mVelocity*deltaSimTime));
   
   // attempt to ground clamp the actor so that he doesn't go through mountains.
   osg::Vec3 intersection;
   dtCore::RefPtr&lt;dtCore::Isector&gt; query = new 
         dtCore::Isector((&amp;GetGameActorProxy().GetGameManager()-&gt;GetScene()));
   query-&gt;Reset(); 
   query-&gt;SetStartPosition(osg::Vec3(pos.x(),pos.y(),-10000));
   query-&gt;SetDirection(osg::Vec3(0,0,1));
   if (query.get()-&gt;Update())
   {
      osgUtil::IntersectVisitor &amp;iv = query.get()-&gt;GetIntersectVisitor();
      osg::Vec3 p = iv.getHitList(query.get()-&gt;GetLineSegment())[0].getWorldIntersectPoint();
      // make it hover
      pos.z() = p.z() + 2.0f;
   }
   
   osg::Vec3 xyz = GetGameActorProxy().GetRotation();
   xyz[2] += 360.0f * mTurnRate * deltaSimTime;

   tx.SetTranslation(pos);
   SetTransform(&amp;tx);
   GetGameActorProxy().SetRotation(xyz);
}
</code></pre>
<p></p>
<p>
Woah.  There’s some icky vector math going on in there, plus we have this intersection stuff going on.  For now, you just have to trust that it works because the explanation is beyond the scope of this tutorial. One thing you should notice is that this method uses ‘mVelocity’ and ‘mTurnRate’ to move the tank.  We better do something to change those!  Let’s check out the next method.
</p>
<p>
In “HoverTankActor.cpp”:
</p>
<p>
</p><pre><code>
///////////////////////////////////////////////////////////////////////////////
void HoverTankActor::ComputeVelocityAndTurn(float deltaSimTime)
{
   // calculate current velocity
   float decelDirection = (mVelocity &gt;= 0.0) ? -1.0f : 1.0f;
   float accelDirection = 0.0f;
   float acceleration = 0.0;

   dtCore::Keyboard *keyboard = GetGameActorProxy().GetGameManager()-&gt;GetApplication().GetKeyboard();

   // which way is the user trying to go? 
   if (keyboard-&gt;GetKeyState(Producer::Key_I))
      accelDirection = -1.0f;
   else if (keyboard-&gt;GetKeyState(Producer::Key_K))
      accelDirection = 1.0f;

   // speed up based on user and current speed (ie, too fast)
   if (mIsEngineRunning &amp;&amp; accelDirection != 0.0f)
   {
       //  boosted too fast, slow down
      if ((accelDirection &gt; 0 &amp;&amp; mVelocity &gt; MAXTANKVELOCITY) ||
            (accelDirection &lt; 0 &amp;&amp; mVelocity &lt; -MAXTANKVELOCITY))
         acceleration = deltaSimTime*(MAXTANKVELOCITY/3.0f)*decelDirection;
      // hold speed
      else if (mVelocity == accelDirection * MAXTANKVELOCITY)
         acceleration = 0;
      // speed up normally - woot!
      else 
         acceleration = accelDirection*deltaSimTime*(MAXTANKVELOCITY/2.0f);
   }
   else if (mVelocity &gt; -0.1 &amp;&amp; mVelocity &lt; 0.1)
      acceleration = -mVelocity; // close enough to 0, so just stop
   else // coast to stop
      acceleration = deltaSimTime*(MAXTANKVELOCITY/6.0f)*decelDirection;

   SetVelocity(mVelocity + acceleration);

   if (mIsEngineRunning &amp;&amp; keyboard-&gt;GetKeyState(Producer::Key_L))
      SetTurnRate(-0.25f);
   else if (mIsEngineRunning &amp;&amp; keyboard-&gt;GetKeyState(Producer::Key_J))
      SetTurnRate(0.25f);
   else 
      SetTurnRate(0.0f);
}
</code></pre>
<p></p>
<p>
Again, the details are beyond the scope of this tutorial.  It is important to notice that we are actually polling the keyboard directly, each tick.  We call keyboard.GetKeyState() to determine if the various speed (‘I’ and ‘K’) and direction (‘J’ and ‘L’) keys are pressed.  That’s what we use to call SetTurnRate() and SetVelocity(). Well that’s interesting.  Didn’t we trap keyboard events in our TutorialInputComponent? Yes, we did.  So, here we see another way to deal with the keyboard that is directly on an Actor, instead of on a component. 
</p>
<p>
To finish up, let’s go back and revisit our Set methods from earlier.  
</p>
<p>
In “HoverTankActor.cpp”:
</p>
<p>
</p><pre><code>
///////////////////////////////////////////////////////////////////////////////
void HoverTankActor::SetTurnRate(float rate)
{
   if (mTurnRate != rate)
   {
      mTurnRate = rate;
      // Notify the world that our turn rate changed. Only changes on keypress
      GetGameActorProxy().NotifyFullActorUpdate();
   }
}
</code></pre>
<p></p>
<p>
Notice the call to NotifyFullActorUpdate() here.  We add that so that we will send out a message when our actor changes.  This is VERY important.  If you are running a networked game, or want to add the ability to do playback, then you MUST send out updates when your actor significantly changes. Ok, let’s check out our velocity:
</p>
<p>
</p><pre><code>
///////////////////////////////////////////////////////////////////////////////
void HoverTankActor::SetVelocity(float velocity)
{
   mVelocity = velocity;

   // Notify the world that our velocity changed, if there is enough difference
   // In a more sophisticated app, you would track acceleration, not just velocity
   // And then you wouldn't have to send velocity but every so often, since acceleration
   // would allow you to dead reckon the position without a network update.
   if ((fabs(fabs(mLastReportedVelocity) - fabs(mVelocity)) &gt; 0.5) || 
      (mLastReportedVelocity != mVelocity &amp;&amp; 
         (mVelocity == MAXTANKVELOCITY || mVelocity == 0.0f || mVelocity == -MAXTANKVELOCITY )))
   {
      mLastReportedVelocity = mVelocity;
      GetGameActorProxy().NotifyFullActorUpdate();
   }
}
</code></pre>
<p></p>
<p>
Here we do very similar behavior.  This time however, we have a bit of extra logic. In order to decay our velocity over time (speeding up and slowing down), we have to change our velocity almost every tick.  However, we certainly don’t want to send a full actor update every tick.  Instead, we send it out periodically.  In a more sophisticated app, you would also use ‘acceleration’.  Since our acceleration is pretty linear, we would rarely need to send update messages out.  Then, remote clients would get periodic updates for the acceleration and could dead-reckon between them. 
</p>
<p>
Alright, we have finished our hover tank actor!  So, let’s recap. We have a hover tank that responds to game events and turns its engines on and off. This causes a particle system to be attached to blow dust.  Then we also have the ability to set the hover tank’s velocity and turn rate and make sure it is ground clamped. And we make sure that when a property on the tank actor changes, the world is notified using an ActorUpdateMessage. We also trap the keyboard input so we can speed up and slow down our tank.  
</p>
<p>
<i>
Helpful Hint – In SetVelocity(), we call NotifyFullActorUpdate() on the ActorProxy.  This method takes all of the properties on the actor and puts them into one large ActorUpdateMessage.  Alternately, we could have build our own ActorUpdateMessage with just the fields that changed.  There are already methods, PopulateActorUpdate() and NotifyActorUpdate() on GameActorProxy to help you along the way. Most complex applications will eventually get to the point where they send frequent position and rotation updates, but infrequent updates for larger sets of data like a characters graphical appearance.  For instance, a networked role-playing game would send lots of updates about player position and rotation, medium updates about health, and few updates about race, class, and level. 
</i>
</p>
<p>
<i>
Helpful Hint – Although we didn’t do it in our tutorial, there is often a need to create Actors on the fly, directly in code. You’d do this for anything that isn’t statically placed in your map. Here’s an example of how you do that using the TaskActor:
<br>
</i></p><pre><i><code> 
      dtCore::RefPtr&lt;dtActors::TaskActorProxy&gt; rollupTaskProxy;
      mGameManager-&gt;CreateActor("dtcore.Tasks","Rollup Task Actor", rollupTaskProxy);
</code></i></pre><i>
</i>
<p></p>
<p>
</p><h2>
Conclusion
</h2>
<p>
Here’s what our tank looks like running in circles:
</p>
<p>
</p><center>
<img width="640" height="480" src="./GameManager Tutorial Parts 3 and 4_files/20060620134503728_1.jpg" alt="">
<br>
<b>Figure 8 Tutorial Screenshot</b>
</center>
<p></p>
<p>
So that’s pretty much it!  We now have a game that controls our hover tank actor and we have learned about invokables, game messages, ticks, and all that good stuff.  Using the basic code presented here, you should have enough information to do just about anything you want using the Game Manager architecture!  Hope you had fun!  
</p>
<p>
To see the final code, check out the <a href="https://web.archive.org/web/20160409060343/http://www.delta3d.org/filemgmt/visit.php?lid=84">tutorial project</a>.
</p>
<p>
Click <a href="https://web.archive.org/web/20160409060343/http://www.delta3d.org/article.php?story=20050720155458456&amp;topic=tutorials">here</a> to return to the tutorials page.
</p>
<p></p>
		<p></p>
		<div style="clear:both;"></div>
		<div style="float:left;" id="fb-root" class=" fb_reset"><div style="position: absolute; top: -10000px; height: 0px; width: 0px;"><div><iframe name="fb_xdm_frame_http" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" id="fb_xdm_frame_http" aria-hidden="true" title="Facebook Cross Domain Communication Frame" tabindex="-1" src="./GameManager Tutorial Parts 3 and 4_files/xd_arbiter.html" style="border: none;" allow="autoplay &#39;self&#39;; fullscreen &#39;self&#39;"></iframe><iframe name="fb_xdm_frame_https" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" id="fb_xdm_frame_https" aria-hidden="true" title="Facebook Cross Domain Communication Frame" tabindex="-1" src="./GameManager Tutorial Parts 3 and 4_files/xd_arbiter(1).html" style="border: none;" allow="autoplay &#39;self&#39;; fullscreen &#39;self&#39;"></iframe></div></div><div style="position: absolute; top: -10000px; height: 0px; width: 0px;"><div></div></div></div>
		<script>(function(d, s, id) {
		  var js, fjs = d.getElementsByTagName(s)[0];
		  if (d.getElementById(id)) return;
		  js = d.createElement(s); js.id = id;
		  js.src = "//web.archive.org/web/20160409060343/http://connect.facebook.net/en_EN/all.js#xfbml=1";
		  fjs.parentNode.insertBefore(js, fjs);
		}(document, 'script', 'facebook-jssdk'));</script>
	    <div style="float:left;margin-right:10px;"><fb:like href="http://delta3d.org/article.php?story=20060620134503728" send="false" layout="button_count" width="90" show_faces="false" class=" fb_iframe_widget" fb-xfbml-state="rendered" fb-iframe-plugin-query="app_id=&amp;container_width=0&amp;href=http%3A%2F%2Fdelta3d.org%2Farticle.php%3Fstory%3D20060620134503728&amp;layout=button_count&amp;locale=en_US&amp;sdk=joey&amp;send=false&amp;show_faces=false&amp;width=90"><span style="vertical-align: top; width: 0px; height: 0px; overflow: hidden;"><iframe name="f1c4cf9bfce8e4b" width="90px" height="1000px" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" title="fb:like Facebook Social Plugin" src="./GameManager Tutorial Parts 3 and 4_files/like.html" style="border: none; visibility: visible; width: 0px; height: 0px;" allow="autoplay &#39;self&#39;; fullscreen &#39;self&#39;"></iframe></span></fb:like></div>
		<div style="float:left;margin-right:-20px;"><iframe id="twitter-widget-1" scrolling="no" frameborder="0" allowtransparency="true" class="twitter-share-button twitter-share-button-rendered twitter-tweet-button" style="position: absolute; visibility: hidden; width: 0px; height: 0px;" allow="autoplay &#39;self&#39;; fullscreen &#39;self&#39;" title="Twitter Tweet Button" src="./GameManager Tutorial Parts 3 and 4_files/tweet_button.fd774b599f565016d763dd860cb31c79.en.html" data-url="http://delta3d.org/article.php?story=20060620134503728"></iframe>
        </div><script>!function(d,s,id) { var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)) { js=d.createElement(s);js.id=id;js.src="https://web.archive.org/web/20160409060343/https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs); } }(document,"script","twitter-wjs");</script>
		<div style="position: absolute; width: 450px; left: -10000px;" id="___plusone_0"><iframe frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="position:absolute;top:-10000px;width:450px;margin:0px;border-style:none" tabindex="0" vspace="0" width="100%" id="I0_1460181827984" name="I0_1460181827984" src="./GameManager Tutorial Parts 3 and 4_files/fastbutton.html" allow="autoplay &#39;self&#39;; fullscreen &#39;self&#39;"></iframe></div><div style="float:left;" class="g-plusone" data-size="medium" data-href="http://delta3d.org/article.php?story=20060620134503728" data-gapiscan="true" data-onload="true" data-gapistub="true"></div>
		<div style="position: absolute; width: 450px; left: -10000px;" id="___plus_0"><iframe frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="position:absolute;top:-10000px;width:450px;margin:0px;border-style:none" tabindex="0" vspace="0" width="100%" id="I1_1460181827988" name="I1_1460181827988" src="./GameManager Tutorial Parts 3 and 4_files/sharebutton.html" allow="autoplay &#39;self&#39;; fullscreen &#39;self&#39;"></iframe></div><div class="g-plus" data-action="share" data-annotation="bubble" data-href="http://delta3d.org/article.php?story=20060620134503728" data-gapiscan="true" data-onload="true" data-gapistub="true"></div>
		<div style="clear:both;"></div>
		<div style="margin-top:5px;">
                
        </div>
    </div>
	<div class="clearboth"></div>
</div>


		<div class="clearboth"></div>
		  <div id="story-whatsrelatedandoptions">
            <div id="story-whatsrelated"><!-- start blockheader-related.thtml -->
<div class="block-box-left">
    <span class="block-helpicon">
        
    </span>
    <h2>What's Related</h2>
<ul class="list-whats-related">
  <li><a href="https://web.archive.org/web/20160409060343/http://www.delta3d.org/article.php?story=20060620123144266&amp;topic=tutorials">here</a></li>
  <li><a href="https://web.archive.org/web/20160409060343/http://www.delta3d.org/article.php?story=20051207101455773&amp;topic=docs">Game Manager Design Doc...</a></li>
  <li><a href="https://web.archive.org/web/20160409060343/http://www.delta3d.org/filemgmt/visit.php?lid=84">tutorial project</a></li>
  <li><a href="https://web.archive.org/web/20160409060343/http://www.delta3d.org/article.php?story=20050720155458456&amp;topic=tutorials">here</a></li>
  <li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/search.php?mode=search&amp;type=stories&amp;author=13">More by coonan</a></li>
  <li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/search.php?mode=search&amp;type=stories&amp;topic=tutorials">More from Tutorials</a></li>

</ul>
</div>
<div style="clear:both;"></div>

</div>
            <div id="story-storyoptions"><!-- start blockheader-related.thtml -->
<div class="block-box-left">
    <span class="block-helpicon">
        
    </span>
    <h2>Story Options</h2>
<ul class="list-story-options">
  <li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/profiles.php?sid=20060620134503728&amp;what=emailstory">Mail Story to a Friend</a></li>
  <li><a href="https://web.archive.org/web/20160409060343/http://delta3d.org/article.php?story=20060620134503728&amp;mode=print" rel="nofollow">Printable Story Format</a></li>

</ul>
</div>
<div style="clear:both;"></div>

</div>
		  </div>
		<div class="clearboth"></div>
		<div id="comments">
        
		</div>
		<div id="story-trackbacks"><h2><a name="trackback">Trackback</a></h2>
<p>Trackback URL for this entry: http://delta3d.org/trackback.php?id=20060620134503728</p>
No trackback comments for this entry.

</div>

	<!-- END OF CONTENT AREA -->
            </div> <!-- end of gl_content -->
        </div> <!-- end of gl_wrapper -->
<!-- Start of Left blocks -->
    <div id="gl_navigation">
        <div class="block-columnpad"><div class="block-box-left">
    <span class="block-helpicon-left">
        
    </span>
    <h2 class="block-title-left">News</h2>
<a href="https://web.archive.org/web/20160409060343/http://caperholdings.com/contracting-services" target="_blank">Need Professional Support?</a>

</div><div class="block-box-left">
    <span class="block-helpicon-left">
        
    </span>
    <h2 class="block-title-left">About delta3d</h2>
delta3d is a game and simulation engine appropriate for a wide variety of simulation and entertainment applications.  delta3d uses best-of-breed open source technologies to create a fully integrated game engine and with content creation tools.<a href="https://web.archive.org/web/20160409060343/http://delta3d.org/index.php?topic=about">MORE</a>
</div><div class="block-box-left">
    <span class="block-helpicon-left">
        <a href="https://web.archive.org/web/20160409060343/http://caperholdings.com/sponsor-delta3d" class="blocktitle"><img src="./GameManager Tutorial Parts 3 and 4_files/button_help.png" alt="?"></a>
    </span>
    <h2 class="block-title-left">Sponsor delta3d</h2>
For the past few years Caper Holdings LLC has been solely driving development of delta3d. To continue to provide upgrades and releases we are allowing the community to purchase <a href="https://web.archive.org/web/20160409060343/http://caperholdings.com/sponsor-delta3d">sponsorships</a>
</div><div class="block-box-left">
    <span class="block-helpicon-left">
        
    </span>
    <h2 class="block-title-left">Twitter</h2>
<iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" class="twitter-timeline twitter-timeline-rendered" style="position: absolute; visibility: hidden; display: block; width: 0px; height: 0px; padding: 0px; border: none;" allow="autoplay &#39;self&#39;; fullscreen &#39;self&#39;" src="./GameManager Tutorial Parts 3 and 4_files/saved_resource.html"></iframe><a class="twitter-timeline twitter-timeline-error" href="https://web.archive.org/web/20160409060343/https://twitter.com/delta3d" data-widget-id="510256513730875393" data-twitter-extracted-i1460181831409191404="true">Tweets by @delta3d</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id))}(document,"script","twitter-wjs");</script>
</div><div class="block-box-left">
    <span class="block-helpicon-left">
        
    </span>
    <h2 class="block-title-left">User Functions</h2>
<!-- loginform.thtml -->

<div id="login_form">
	<h2 id="login_button" class="login_options">
		<a style="padding-right:20px;" href="https://web.archive.org/web/20160409060343/http://delta3d.org/article.php?story=20060620134503728&amp;topic=tutorials#" title="" onclick="return false;">Login</a>
	</h2>

	<div id="loginblock" class="loginblock">
		<div id="loginblock-content">
			<div id="loginform">
				<form action="https://web.archive.org/web/20160409060343/http://delta3d.org/users.php" method="post" style="padding-bottom:5px;">
				<label for="loginname">Username:</label><br>
				<input type="text" size="10" name="loginname" value="" id="loginname"><br>
				
				<label for="passwd">Password:</label><br>
				<input type="password" size="10" name="passwd" id="passwd"><br>
				<input type="submit" name="submit_login" value="Login" style="margin-top:5px;">
				</form>
			</div>
			<p>Don't have an account yet?  Sign up as a <a href="https://web.archive.org/web/20160409060343/http://delta3d.org/users.php?mode=new" rel="nofollow">New User</a></p>
			<p>Lost your <a href="https://web.archive.org/web/20160409060343/http://delta3d.org/users.php?mode=getpassword" rel="nofollow">password</a>?</p>

		</div>
	</div>
    
	
</div>
<!-- /loginform.thtml -->
</div></div>
    </div>
<!-- End of Left blocks -->

        </div> <!-- end of gl_content_container -->
        <div id="gl_footer">
			<div id="footer_container">
			</div> <!-- end of footer_container -->
        </div> <!-- end of gl_footer-->

</div> <!-- end of container -->




    <!--[if lte IE 6]>
        <script type="text/javascript" src="http://delta3d.org/layout/purepro/js/gl_moopngfix.js" defer="defer" ></script>
    <![endif]-->

    <!--[if lt IE 7.]>
        <script defer type="text/javascript" src="http://delta3d.org/layout/purepro/js/pngfix.js"></script>
    <![endif]-->

</div></div></div>
<!-- End of layers -->

<script type="text/javascript">
var geeklogEditorBaseUrl = "https://web.archive.org/web/20160409060343/http://delta3d.org";
var geeklogEditorBasePath = "https://web.archive.org/web/20160409060343/http://delta3d.org/fckeditor/";
</script>
<script type="text/javascript" src="./GameManager Tutorial Parts 3 and 4_files/common.js.download"></script>
<script type="text/javascript" src="./GameManager Tutorial Parts 3 and 4_files/jquery.min.js.download"></script>




<!--
playback timings (ms):
  CDXLines.iter: 19.676 (3)
  captures_list: 214.823
  RedisCDXSource: 1.177
  esindex: 0.014
  exclusion.robots: 0.343
  LoadShardBlock: 189.982 (3)
  PetaboxLoader3.datanode: 396.194 (4)
  PetaboxLoader3.resolve: 115.34
  exclusion.robots.policy: 0.312
  load_resource: 418.714
--><script src="./GameManager Tutorial Parts 3 and 4_files/510256513730875393" async=""></script><iframe id="rufous-sandbox" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" style="position: absolute; visibility: hidden; display: none; width: 0px; height: 0px; padding: 0px; border: none;" allow="autoplay &#39;self&#39;; fullscreen &#39;self&#39;" src="./GameManager Tutorial Parts 3 and 4_files/saved_resource(1).html"></iframe></body></html>